#!/usr/bin/env bash
#/************************************************************************/
#/**
# * @file pod-ssh-clean-worker
# * @brief 
# * @author Anar Manafov A.Manafov@gsi.de
# *//*
#
#        created by:        Anar Manafov
#                           2010-06-10
#
#        Copyright (c) 2010 GSI, Scientific Computing group. All rights reserved.
#*************************************************************************/
#
# Usage
# $1 ssh host (login@host.fqdn)
# $2 remote working dir
# $3 ssh params

TOOL_NAME="pod-ssh-clean-worker"
WRK_PID=PoDWorker.pid
TIMEOUT=30

SSH_CMD="ssh -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$TIMEOUT -o PasswordAuthentication=no -q $1 $3"
SCP_CMD="scp -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=$TIMEOUT -o PasswordAuthentication=no $3"
WAITTIMEOUT=10
# a pod-ssh communication pipe (log engine)
pipe="$POD_LOCATION/.ssh_plugin_pipe"
if [[ ! -p $pipe ]]; then
    echo "$TOOL_NAME error: pod-ssh log engine is not running"
    exit 1
fi
logMsg()
{
# date format
#RFC-2822:
# *    www, dd mmm yyyy hh:mm:ss +zzzz
#
# Don't use date -R since it's a GNU specific implementation (doesn't work on Mac, for example)
    echo "*** [$(date '+%a, %d %b %Y %T %z')]   $1" > $pipe
}


# a special case, executed on the remote host
# check for pid file of worker's script.
# If the file is available, read pid from it and send a TERM signal using that pid.
# If the file is unavailable, exit with 0 - it is not an error for us.
if [ "$1" = "clean" ]; then
    pid_file="$2/$WRK_PID"
    
    if [  -e $pid_file ]; then
	pid=$(cat $pid_file)
	kill -15 $pid
	cnt=0
	while $(kill -0 $pid &>/dev/null); do
	   cnt=$(expr $cnt + 1)
	   if [ $cnt -gt $WAITTIMEOUT ]; then
	      echo "$TOOL_NAME error: failed to wait for pid $pid"
	      exit 1
	   fi
	   sleep 1
	done
    fi

    exit 0
fi

# this part is executed locally
SELF_PATH=$(readlink -f $0)

$SSH_CMD "test -d $2" &> $pipe
if [ $? -ne 0 ]; then
   exit 0
fi

$SCP_CMD $SELF_PATH $1:$2/  &> $pipe
if [ $? -ne 0 ]; then
    logMsg "$TOOL_NAME error: failed to send worker's cleaning script $SELF_PATH"
    exit 1
fi

# Submit a cleaning script
$SSH_CMD "$2/$TOOL_NAME clean $2"  &> $pipe
if [ $? -ne 0 ]; then
    logMsg "$TOOL_NAME error: failed to stop PoD worker."
    exit 1
fi

# remove the working directory
$SSH_CMD "rm -rf $2"  &> $pipe
if [ $? -ne 0 ]; then
    logMsg "$TOOL_NAME error: failed to remove the remote working dir: $2"
    exit 1
fi

exit 0

